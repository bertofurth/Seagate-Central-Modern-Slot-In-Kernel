diff -rup linux-6.1.26.orig/fs/ext2/ext2.h linux-6.1.26/fs/ext2/ext2.h
--- linux-6.1.26.orig/fs/ext2/ext2.h	2023-04-26 22:28:44.000000000 +1000
+++ linux-6.1.26/fs/ext2/ext2.h	2023-05-03 13:12:07.426052742 +1000
@@ -178,7 +178,11 @@ static inline struct ext2_sb_info *EXT2_
  * Macro-instructions used to manage several block sizes
  */
 #define EXT2_MIN_BLOCK_SIZE		1024
+#ifdef CONFIG_ARM_64KB_MMU_PAGE_SIZE_SUPPORT
+#define	EXT2_MAX_BLOCK_SIZE		PAGE_SIZE
+#else
 #define	EXT2_MAX_BLOCK_SIZE		4096
+#endif
 #define EXT2_MIN_BLOCK_LOG_SIZE		  10
 #define EXT2_BLOCK_SIZE(s)		((s)->s_blocksize)
 #define	EXT2_ADDR_PER_BLOCK(s)		(EXT2_BLOCK_SIZE(s) / sizeof (__u32))
diff -rup linux-6.1.26.orig/fs/proc/task_mmu.c linux-6.1.26/fs/proc/task_mmu.c
--- linux-6.1.26.orig/fs/proc/task_mmu.c	2023-04-26 22:28:44.000000000 +1000
+++ linux-6.1.26/fs/proc/task_mmu.c	2023-05-03 13:12:07.430052737 +1000
@@ -632,7 +632,11 @@ static int smaps_pte_range(pmd_t *pmd, u
 	 * in here.
 	 */
 	pte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);
+#ifdef CONFIG_ARM_64KB_MMU_PAGE_SIZE_SUPPORT
+	for (; addr != end; pte += PTE_STEP, addr += PAGE_SIZE)
+#else
 	for (; addr != end; pte++, addr += PAGE_SIZE)
+#endif
 		smaps_pte_entry(pte, addr, walk);
 	pte_unmap_unlock(pte - 1, ptl);
 out:
@@ -1189,7 +1193,11 @@ out:
 		return 0;
 
 	pte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);
+#ifdef CONFIG_ARM_64KB_MMU_PAGE_SIZE_SUPPORT
+	for (; addr != end; pte += PTE_STEP, addr += PAGE_SIZE) {
+#else
 	for (; addr != end; pte++, addr += PAGE_SIZE) {
+#endif
 		ptent = *pte;
 
 		if (cp->type == CLEAR_REFS_SOFT_DIRTY) {
@@ -1542,7 +1550,11 @@ static int pagemap_pmd_range(pmd_t *pmdp
 	 * goes beyond vma->vm_end.
 	 */
 	orig_pte = pte = pte_offset_map_lock(walk->mm, pmdp, addr, &ptl);
+#ifdef CONFIG_ARM_64KB_MMU_PAGE_SIZE_SUPPORT
+	for (; addr < end; pte += PTE_STEP, addr += PAGE_SIZE) {
+#else
 	for (; addr < end; pte++, addr += PAGE_SIZE) {
+#endif
 		pagemap_entry_t pme;
 
 		pme = pte_to_pagemap_entry(pm, vma, addr, *pte);
@@ -1886,8 +1898,11 @@ static int gather_pte_stats(pmd_t *pmd,
 		if (!page)
 			continue;
 		gather_stats(page, md, pte_dirty(*pte), 1);
-
+#ifdef CONFIG_ARM_64KB_MMU_PAGE_SIZE_SUPPORT
+	} while (pte += PTE_STEP, addr += PAGE_SIZE, addr != end);
+#else
 	} while (pte++, addr += PAGE_SIZE, addr != end);
+#endif
 	pte_unmap_unlock(orig_pte, ptl);
 	cond_resched();
 	return 0;
