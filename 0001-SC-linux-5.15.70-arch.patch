diff -rup linux-5.15.70-orig/arch/arm/include/asm/elf.h linux-5.15.70/arch/arm/include/asm/elf.h
--- linux-5.15.70-orig/arch/arm/include/asm/elf.h	2022-09-23 22:15:52.000000000 +1000
+++ linux-5.15.70/arch/arm/include/asm/elf.h	2022-10-04 19:26:32.763488256 +1100
@@ -117,7 +117,7 @@ extern int arm_elf_read_implies_exec(int
 #define elf_read_implies_exec(ex,stk) arm_elf_read_implies_exec(stk)
 
 #define CORE_DUMP_USE_REGSET
-#define ELF_EXEC_PAGESIZE	4096
+#define ELF_EXEC_PAGESIZE	PAGE_SIZE
 
 /* This is the base location for PIE (ET_DYN with INTERP) loads. */
 #define ELF_ET_DYN_BASE		0x400000UL
diff -rup linux-5.15.70-orig/arch/arm/include/asm/fixmap.h linux-5.15.70/arch/arm/include/asm/fixmap.h
--- linux-5.15.70-orig/arch/arm/include/asm/fixmap.h	2022-09-23 22:15:52.000000000 +1000
+++ linux-5.15.70/arch/arm/include/asm/fixmap.h	2022-10-04 19:26:32.763488256 +1100
@@ -8,6 +8,7 @@
 
 #include <linux/pgtable.h>
 #include <asm/kmap_size.h>
+#include <linux/sizes.h>
 
 enum fixed_addresses {
 	FIX_EARLYCON_MEM_BASE,
@@ -27,7 +28,7 @@ enum fixed_addresses {
 	 * not to clash since early_ioremap() is only available before
 	 * paging_init(), and kmap() only after.
 	 */
-#define NR_FIX_BTMAPS		32
+#define NR_FIX_BTMAPS		(SZ_128K / PAGE_SIZE)
 #define FIX_BTMAPS_SLOTS	7
 #define TOTAL_FIX_BTMAPS	(NR_FIX_BTMAPS * FIX_BTMAPS_SLOTS)
 
diff -rup linux-5.15.70-orig/arch/arm/include/asm/page.h linux-5.15.70/arch/arm/include/asm/page.h
--- linux-5.15.70-orig/arch/arm/include/asm/page.h	2022-09-23 22:15:52.000000000 +1000
+++ linux-5.15.70/arch/arm/include/asm/page.h	2022-10-04 19:26:32.763488256 +1100
@@ -8,7 +8,11 @@
 #define _ASMARM_PAGE_H
 
 /* PAGE_SHIFT determines the page size */
+#ifdef CONFIG_ARM_64KB_MMU_PAGE_SIZE_SUPPORT
+#define PAGE_SHIFT              16
+#else
 #define PAGE_SHIFT		12
+#endif
 #define PAGE_SIZE		(_AC(1,UL) << PAGE_SHIFT)
 #define PAGE_MASK		(~((1 << PAGE_SHIFT) - 1))
 
diff -rup linux-5.15.70-orig/arch/arm/include/asm/pgtable-2level.h linux-5.15.70/arch/arm/include/asm/pgtable-2level.h
--- linux-5.15.70-orig/arch/arm/include/asm/pgtable-2level.h	2022-09-23 22:15:52.000000000 +1000
+++ linux-5.15.70/arch/arm/include/asm/pgtable-2level.h	2022-10-04 19:26:32.763488256 +1100
@@ -71,6 +71,20 @@
 #define PTRS_PER_PMD		1
 #define PTRS_PER_PGD		2048
 
+/*
+ * Irrespective of the page size, the number of entries in the L2 page
+ * table remain the same and is set to 512 as indicated by PTS_PER_PTE.
+ * When the page size is set to 64K each unique page table entry has
+ * (64K / 4K) = 16 copies (PTE_STEP). This means there are only 
+ * (PTRS_PER_PTE / PTE_STEP) = (512 / 16) = 32 unique Page Table 
+ * Entries (PTRS_PER_PTE_REAL). This needs to be born in mind when
+ * walking a page table.
+ */
+#ifdef CONFIG_ARM_64KB_MMU_PAGE_SIZE_SUPPORT
+#define PTRS_PER_PTE_REAL       32
+#define PTE_STEP                16
+#endif
+
 #define PTE_HWTABLE_PTRS	(PTRS_PER_PTE)
 #define PTE_HWTABLE_OFF		(PTE_HWTABLE_PTRS * sizeof(pte_t))
 #define PTE_HWTABLE_SIZE	(PTRS_PER_PTE * sizeof(u32))
diff -rup linux-5.15.70-orig/arch/arm/include/asm/pgtable-2level-hwdef.h linux-5.15.70/arch/arm/include/asm/pgtable-2level-hwdef.h
--- linux-5.15.70-orig/arch/arm/include/asm/pgtable-2level-hwdef.h	2022-09-23 22:15:52.000000000 +1000
+++ linux-5.15.70/arch/arm/include/asm/pgtable-2level-hwdef.h	2022-10-04 19:26:32.775488359 +1100
@@ -66,7 +66,11 @@
 /*
  *   - extended small page/tiny page
  */
+#ifdef CONFIG_ARM_64KB_MMU_PAGE_SIZE_SUPPORT
+#define PTE_EXT_XN		(_AT(pteval_t, 1) << 15)	/* v6 */
+#else
 #define PTE_EXT_XN		(_AT(pteval_t, 1) << 0)		/* v6 */
+#endif
 #define PTE_EXT_AP_MASK		(_AT(pteval_t, 3) << 4)
 #define PTE_EXT_AP0		(_AT(pteval_t, 1) << 4)
 #define PTE_EXT_AP1		(_AT(pteval_t, 2) << 4)
@@ -74,7 +78,11 @@
 #define PTE_EXT_AP_UNO_SRW	(PTE_EXT_AP0)
 #define PTE_EXT_AP_URO_SRW	(PTE_EXT_AP1)
 #define PTE_EXT_AP_URW_SRW	(PTE_EXT_AP1|PTE_EXT_AP0)
+#ifdef CONFIG_ARM_64KB_MMU_PAGE_SIZE_SUPPORT
+#define PTE_EXT_TEX(x)		(_AT(pteval_t, (x)) << 12)	/* Large Page */
+#else
 #define PTE_EXT_TEX(x)		(_AT(pteval_t, (x)) << 6)	/* v5 */
+#endif
 #define PTE_EXT_APX		(_AT(pteval_t, 1) << 9)		/* v6 */
 #define PTE_EXT_COHERENT	(_AT(pteval_t, 1) << 9)		/* XScale3 */
 #define PTE_EXT_SHARED		(_AT(pteval_t, 1) << 10)	/* v6 */
diff -rup linux-5.15.70-orig/arch/arm/include/asm/pgtable.h linux-5.15.70/arch/arm/include/asm/pgtable.h
--- linux-5.15.70-orig/arch/arm/include/asm/pgtable.h	2022-09-23 22:15:52.000000000 +1000
+++ linux-5.15.70/arch/arm/include/asm/pgtable.h	2022-10-04 19:26:32.775488359 +1100
@@ -58,7 +58,11 @@ extern void __pgd_error(const char *file
  * mapping to be mapped at.  This is particularly important for
  * non-high vector CPUs.
  */
+#ifdef CONFIG_ARM_64KB_MMU_PAGE_SIZE_SUPPORT
+#define FIRST_USER_ADDRESS      PAGE_SIZE
+#else
 #define FIRST_USER_ADDRESS	(PAGE_SIZE * 2)
+#endif /* CONFIG_ARM_64KB_MMU_PAGE_SIZE_SUPPORT */
 
 /*
  * Use TASK_SIZE as the ceiling argument for free_pgtables() and
@@ -178,6 +182,16 @@ static inline pte_t *pmd_page_vaddr(pmd_
 
 #define pmd_page(pmd)		pfn_to_page(__phys_to_pfn(pmd_val(pmd) & PHYS_MASK))
 
+#ifdef CONFIG_ARM_64KB_MMU_PAGE_SIZE_SUPPORT
+#define pte_index(addr)         (((addr) >> PAGE_SHIFT) & \
+				 (PTRS_PER_PTE_REAL - 1))
+#define pte_offset_kernel(dir, addr)    (pmd_page_vaddr(*(dir)) + \
+					 pte_index(addr) * PTE_STEP)
+#define pte_offset_map(pmd, addr)       (pmd_page_vaddr(*(pmd)) +	\
+					 pte_index(addr) * PTE_STEP)
+#define pte_unmap(pte)                   do { } while (0)
+#endif /* CONFIG_ARM_64KB_MMU_PAGE_SIZE_SUPPORT */
+
 #define pte_pfn(pte)		((pte_val(pte) & PHYS_MASK) >> PAGE_SHIFT)
 #define pfn_pte(pfn,prot)	__pte(__pfn_to_phys(pfn) | pgprot_val(prot))
 
diff -rup linux-5.15.70-orig/arch/arm/include/asm/shmparam.h linux-5.15.70/arch/arm/include/asm/shmparam.h
--- linux-5.15.70-orig/arch/arm/include/asm/shmparam.h	2022-09-23 22:15:52.000000000 +1000
+++ linux-5.15.70/arch/arm/include/asm/shmparam.h	2022-10-04 19:26:32.775488359 +1100
@@ -7,7 +7,11 @@
  * or page size, whichever is greater since the cache aliases
  * every size/ways bytes.
  */
+#ifdef CONFIG_ARM_64KB_MMU_PAGE_SIZE_SUPPORT
+#define SHMLBA  (PAGE_SIZE)
+#else
 #define	SHMLBA	(4 * PAGE_SIZE)		 /* attach addr a multiple of this */
+#endif
 
 /*
  * Enforce SHMLBA in shmat
diff -rup linux-5.15.70-orig/arch/arm/include/asm/thread_info.h linux-5.15.70/arch/arm/include/asm/thread_info.h
--- linux-5.15.70-orig/arch/arm/include/asm/thread_info.h	2022-09-23 22:15:52.000000000 +1000
+++ linux-5.15.70/arch/arm/include/asm/thread_info.h	2022-10-04 19:26:32.775488359 +1100
@@ -13,6 +13,9 @@
 #include <asm/fpstate.h>
 #include <asm/page.h>
 
+#ifdef CONFIG_ARM_64KB_MMU_PAGE_SIZE_SUPPORT
+#define THREAD_SIZE_ORDER       0
+#else
 #ifdef CONFIG_KASAN
 /*
  * KASan uses a lot of extra stack space so the thread size order needs to
@@ -22,6 +25,7 @@
 #else
 #define THREAD_SIZE_ORDER	1
 #endif
+#endif /* CONFIG_ARM_64KB_MMU_PAGE_SIZE_SUPPORT */
 #define THREAD_SIZE		(PAGE_SIZE << THREAD_SIZE_ORDER)
 #define THREAD_START_SP		(THREAD_SIZE - 8)
 
diff -rup linux-5.15.70-orig/arch/arm/include/uapi/asm/setup.h linux-5.15.70/arch/arm/include/uapi/asm/setup.h
--- linux-5.15.70-orig/arch/arm/include/uapi/asm/setup.h	2022-09-23 22:15:52.000000000 +1000
+++ linux-5.15.70/arch/arm/include/uapi/asm/setup.h	2022-10-04 19:26:32.775488359 +1100
@@ -124,7 +124,7 @@ struct tag_videolfb {
 #define ATAG_CMDLINE	0x54410009
 
 struct tag_cmdline {
-	char	cmdline[1];	/* this is the minimum size */
+	char	cmdline[COMMAND_LINE_SIZE];
 };
 
 /* acorn RiscPC specific information */
diff -rup linux-5.15.70-orig/arch/arm/Kconfig linux-5.15.70/arch/arm/Kconfig
--- linux-5.15.70-orig/arch/arm/Kconfig	2022-09-23 22:15:52.000000000 +1000
+++ linux-5.15.70/arch/arm/Kconfig	2022-10-04 19:26:32.783488428 +1100
@@ -337,6 +337,27 @@ config ARM_SINGLE_ARMV7M
 	select SPARSE_IRQ
 	select USE_OF
 
+config ARCH_CNS3XXX
+	bool "Cavium Networks CNS3XXX family"
+	select CPU_V6K	      
+	select ARM_HAS_SG_CHAIN
+	select ARM_GIC
+	select HAVE_ARM_SCU if SMP
+	select HAVE_ARM_TWD
+	select HAVE_SMP
+	select FIQ
+	select TIMER_OF
+	select COMMON_CLK
+	select GENERIC_IRQ_MULTI_HANDLER
+	select SPARSE_IRQ
+	select MIGHT_HAVE_CACHE_L2X0
+	select MIGHT_HAVE_PCI
+	select USE_OF
+	select GENERIC_IRQ_CHIP
+        help
+          Support for Cavium Networks CNS3XXX platform.
+          This includes the Seagate Central NAS.
+
 config ARCH_EP93XX
 	bool "EP93xx-based"
 	select ARCH_SPARSEMEM_ENABLE
@@ -1268,6 +1289,7 @@ config PAGE_OFFSET
 	default PHYS_OFFSET if !MMU
 	default 0x40000000 if VMSPLIT_1G
 	default 0x80000000 if VMSPLIT_2G
+	default 0xA0000000 if CNS3XXX_HIGH_PHYS_OFFSET
 	default 0xB0000000 if VMSPLIT_3G_OPT
 	default 0xC0000000
 
@@ -1276,6 +1298,7 @@ config KASAN_SHADOW_OFFSET
 	depends on KASAN
 	default 0x1f000000 if PAGE_OFFSET=0x40000000
 	default 0x5f000000 if PAGE_OFFSET=0x80000000
+	default 0x7f000000 if PAGE_OFFSET=0xA0000000
 	default 0x9f000000 if PAGE_OFFSET=0xC0000000
 	default 0x8f000000 if PAGE_OFFSET=0xB0000000
 	default 0xffffffff
diff -rup linux-5.15.70-orig/arch/arm/Kconfig.debug linux-5.15.70/arch/arm/Kconfig.debug
--- linux-5.15.70-orig/arch/arm/Kconfig.debug	2022-09-23 22:15:52.000000000 +1000
+++ linux-5.15.70/arch/arm/Kconfig.debug	2022-10-04 19:26:32.783488428 +1100
@@ -1788,7 +1788,6 @@ config DEBUG_UART_VIRT
 				DEBUG_OMAP4UART2 || DEBUG_OMAP5UART2
 	default 0xfa06e000 if DEBUG_OMAP2UART3 || DEBUG_OMAP4UART4
 	default 0xfa71e000 if DEBUG_QCOM_UARTDM
-	default 0xfb002000 if DEBUG_CNS3XXX
 	default 0xfb009000 if DEBUG_REALVIEW_STD_PORT
 	default 0xfb00c000 if DEBUG_AT91_SAMA5D4_USART3
 	default 0xfb020000 if DEBUG_OMAP3UART3
@@ -1831,6 +1830,7 @@ config DEBUG_UART_VIRT
 	default 0xfefb0000 if DEBUG_OMAP1UART1 || DEBUG_OMAP7XXUART1
 	default 0xfefb0800 if DEBUG_OMAP1UART2 || DEBUG_OMAP7XXUART2
 	default 0xfefb9800 if DEBUG_OMAP1UART3 || DEBUG_OMAP7XXUART3
+	default 0xff050000 if DEBUG_CNS3XXX
 	default 0xffd01000 if DEBUG_HIP01_UART
 	default DEBUG_UART_PHYS if !MMU
 	depends on DEBUG_LL_UART_8250 || DEBUG_LL_UART_PL01X || \
diff -rup linux-5.15.70-orig/arch/arm/kernel/entry-common.S linux-5.15.70/arch/arm/kernel/entry-common.S
--- linux-5.15.70-orig/arch/arm/kernel/entry-common.S	2022-09-23 22:15:52.000000000 +1000
+++ linux-5.15.70/arch/arm/kernel/entry-common.S	2022-10-04 19:26:32.791488497 +1100
@@ -426,8 +426,19 @@ ENDPROC(sys_fstatfs64_wrapper)
  * offset, we return EINVAL.
  */
 sys_mmap2:
+#ifdef CONFIG_ARM_64KB_MMU_PAGE_SIZE_SUPPORT
+#define PGOFF_SHIFT (PAGE_SHIFT - 12)
+#define PGOFF_MASK  ((1 << PGOFF_SHIFT) - 1)	
+	        tst     r5, #PGOFF_MASK
+	        moveq   r5, r5, lsr #PGOFF_SHIFT
+	        streq   r5, [sp, #4]
+	        beq     sys_mmap_pgoff
+	        mov     r0, #-EINVAL
+	        ret     lr
+#else	
 		str	r5, [sp, #4]
 		b	sys_mmap_pgoff
+#endif
 ENDPROC(sys_mmap2)
 
 #ifdef CONFIG_OABI_COMPAT
diff -rup linux-5.15.70-orig/arch/arm/kernel/traps.c linux-5.15.70/arch/arm/kernel/traps.c
--- linux-5.15.70-orig/arch/arm/kernel/traps.c	2022-09-23 22:15:52.000000000 +1000
+++ linux-5.15.70/arch/arm/kernel/traps.c	2022-10-04 19:26:32.791488497 +1100
@@ -866,7 +866,11 @@ void __init early_trap_init(void *vector
 
 	kuser_init(vectors_base);
 
+#ifdef CONFIG_ARM_64KB_MMU_PAGE_SIZE_SUPPORT
+	flush_vectors(vectors_base, 0, PAGE_SIZE);
+#else
 	flush_vectors(vectors_base, 0, PAGE_SIZE * 2);
+#endif
 }
 #else /* ifndef CONFIG_CPU_V7M */
 void __init early_trap_init(void *vectors_base)
diff -rup linux-5.15.70-orig/arch/arm/lib/copy_page.S linux-5.15.70/arch/arm/lib/copy_page.S
--- linux-5.15.70-orig/arch/arm/lib/copy_page.S	2022-09-23 22:15:52.000000000 +1000
+++ linux-5.15.70/arch/arm/lib/copy_page.S	2022-10-04 19:26:32.791488497 +1100
@@ -25,7 +25,7 @@ ENTRY(copy_page)
 		stmfd	sp!, {r4, lr}			@	2
 	PLD(	pld	[r1, #0]		)
 	PLD(	pld	[r1, #L1_CACHE_BYTES]		)
-		mov	r2, #COPY_COUNT			@	1
+		ldr	r2, =COPY_COUNT			@	1
 		ldmia	r1!, {r3, r4, ip, lr}		@	4+1
 1:	PLD(	pld	[r1, #2 * L1_CACHE_BYTES])
 	PLD(	pld	[r1, #3 * L1_CACHE_BYTES])
diff -rup linux-5.15.70-orig/arch/arm/mach-cns3xxx/core.c linux-5.15.70/arch/arm/mach-cns3xxx/core.c
--- linux-5.15.70-orig/arch/arm/mach-cns3xxx/core.c	2022-09-23 22:15:52.000000000 +1000
+++ linux-5.15.70/arch/arm/mach-cns3xxx/core.c	2022-10-04 19:26:32.791488497 +1100
@@ -12,48 +12,68 @@
 #include <linux/irqchip/arm-gic.h>
 #include <linux/of_platform.h>
 #include <linux/platform_device.h>
-#include <linux/usb/ehci_pdriver.h>
-#include <linux/usb/ohci_pdriver.h>
 #include <asm/mach/arch.h>
 #include <asm/mach/map.h>
 #include <asm/mach/time.h>
 #include <asm/mach/irq.h>
 #include <asm/hardware/cache-l2x0.h>
-#include "cns3xxx.h"
+//#include <mach/irqs.h>
+#include <linux/platform_data/cns3xxx.h>
 #include "core.h"
-#include "pm.h"
+#include <mach/pm.h>
 
+#define MAX(x, y) (((x) > (y)) ? (x) : (y))
 static struct map_desc cns3xxx_io_desc[] __initdata = {
 	{
 		.virtual	= CNS3XXX_TC11MP_SCU_BASE_VIRT,
 		.pfn		= __phys_to_pfn(CNS3XXX_TC11MP_SCU_BASE),
-		.length		= SZ_8K,
+		.length		= MAX(SZ_8K, PAGE_SIZE),
 		.type		= MT_DEVICE,
 	}, {
 		.virtual	= CNS3XXX_TIMER1_2_3_BASE_VIRT,
 		.pfn		= __phys_to_pfn(CNS3XXX_TIMER1_2_3_BASE),
-		.length		= SZ_4K,
+		.length		= MAX(SZ_4K, PAGE_SIZE),
 		.type		= MT_DEVICE,
 	}, {
 		.virtual	= CNS3XXX_MISC_BASE_VIRT,
 		.pfn		= __phys_to_pfn(CNS3XXX_MISC_BASE),
-		.length		= SZ_4K,
+		.length		= MAX(SZ_4K, PAGE_SIZE),
 		.type		= MT_DEVICE,
 	}, {
+	        .virtual        = CNS3XXX_GPIOA_BASE_VIRT,
+		.pfn            = __phys_to_pfn(CNS3XXX_GPIOA_BASE),
+		.length         = PAGE_SIZE,
+		.type           = MT_DEVICE,
+	}, {
+	        .virtual        = CNS3XXX_GPIOB_BASE_VIRT,
+		.pfn            = __phys_to_pfn(CNS3XXX_GPIOB_BASE),
+		.length         = PAGE_SIZE,
+		.type           = MT_DEVICE,
+	}, {
 		.virtual	= CNS3XXX_PM_BASE_VIRT,
 		.pfn		= __phys_to_pfn(CNS3XXX_PM_BASE),
-		.length		= SZ_4K,
+		.length		= MAX(SZ_4K, PAGE_SIZE),
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= CNS3XXX_SSP_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS3XXX_SSP_BASE),
+		.length		= SZ_64K,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= CNS3XXX_USB_BASE_VIRT,
+		.pfn		= __phys_to_pfn(CNS3XXX_USB_BASE),
+		.length		= SZ_64K,
 		.type		= MT_DEVICE,
 #ifdef CONFIG_PCI
 	}, {
 		.virtual	= CNS3XXX_PCIE0_HOST_BASE_VIRT,
 		.pfn		= __phys_to_pfn(CNS3XXX_PCIE0_HOST_BASE),
-		.length		= SZ_4K,
+		.length		= MAX(SZ_4K, PAGE_SIZE),
 		.type		= MT_DEVICE,
 	}, {
 		.virtual	= CNS3XXX_PCIE0_CFG0_BASE_VIRT,
 		.pfn		= __phys_to_pfn(CNS3XXX_PCIE0_CFG0_BASE),
-		.length		= SZ_64K, /* really 4 KiB at offset 32 KiB */
+		.length		= MAX(SZ_4K, PAGE_SIZE), /* really 4 KiB at offset 32 KiB */
 		.type		= MT_DEVICE,
 	}, {
 		.virtual	= CNS3XXX_PCIE0_CFG1_BASE_VIRT,
@@ -63,7 +83,7 @@ static struct map_desc cns3xxx_io_desc[]
 	}, {
 		.virtual	= CNS3XXX_PCIE1_HOST_BASE_VIRT,
 		.pfn		= __phys_to_pfn(CNS3XXX_PCIE1_HOST_BASE),
-		.length		= SZ_4K,
+		.length		= SZ_64K,
 		.type		= MT_DEVICE,
 	}, {
 		.virtual	= CNS3XXX_PCIE1_CFG0_BASE_VIRT,
@@ -122,6 +142,7 @@ static int cns3xxx_set_oneshot(struct cl
 
 	/* period set, and timer enabled in 'next_event' hook */
 	ctrl |= (1 << 2) | (1 << 9);
+	writel(0, cns3xxx_tmr1 + TIMER1_AUTO_RELOAD_OFFSET);
 	writel(ctrl, cns3xxx_tmr1 + TIMER1_2_CONTROL_OFFSET);
 	return 0;
 }
@@ -132,7 +153,7 @@ static int cns3xxx_set_periodic(struct c
 	int pclk = cns3xxx_cpu_clock() / 8;
 	int reload;
 
-	reload = pclk * 20 / (3 * HZ) * 0x25000;
+	reload = pclk * 1000000 / HZ;
 	writel(reload, cns3xxx_tmr1 + TIMER1_AUTO_RELOAD_OFFSET);
 	ctrl |= (1 << 0) | (1 << 2) | (1 << 9);
 	writel(ctrl, cns3xxx_tmr1 + TIMER1_2_CONTROL_OFFSET);
@@ -159,8 +180,8 @@ static struct clock_event_device cns3xxx
 	.set_state_oneshot	= cns3xxx_set_oneshot,
 	.tick_resume		= cns3xxx_shutdown,
 	.set_next_event		= cns3xxx_timer_set_next_event,
-	.rating			= 350,
-	.cpumask		= cpu_all_mask,
+	.rating			= 300,
+	.cpumask		= cpu_possible_mask,
 };
 
 static void __init cns3xxx_clockevents_init(unsigned int timer_irq)
@@ -257,7 +278,7 @@ void __init cns3xxx_timer_init(void)
 
 void __init cns3xxx_l2x0_init(void)
 {
-	void __iomem *base = ioremap(CNS3XXX_L2C_BASE, SZ_4K);
+	void __iomem *base = ioremap(CNS3XXX_L2C_BASE, MAX(SZ_4K, PAGE_SIZE));
 	u32 val;
 
 	if (WARN_ON(!base))
@@ -295,58 +316,6 @@ void __init cns3xxx_l2x0_init(void)
 
 #endif /* CONFIG_CACHE_L2X0 */
 
-static int csn3xxx_usb_power_on(struct platform_device *pdev)
-{
-	/*
-	 * EHCI and OHCI share the same clock and power,
-	 * resetting twice would cause the 1st controller been reset.
-	 * Therefore only do power up  at the first up device, and
-	 * power down at the last down device.
-	 *
-	 * Set USB AHB INCR length to 16
-	 */
-	if (atomic_inc_return(&usb_pwr_ref) == 1) {
-		cns3xxx_pwr_power_up(1 << PM_PLL_HM_PD_CTRL_REG_OFFSET_PLL_USB);
-		cns3xxx_pwr_clk_en(1 << PM_CLK_GATE_REG_OFFSET_USB_HOST);
-		cns3xxx_pwr_soft_rst(1 << PM_SOFT_RST_REG_OFFST_USB_HOST);
-		__raw_writel((__raw_readl(MISC_CHIP_CONFIG_REG) | (0X2 << 24)),
-			MISC_CHIP_CONFIG_REG);
-	}
-
-	return 0;
-}
-
-static void csn3xxx_usb_power_off(struct platform_device *pdev)
-{
-	/*
-	 * EHCI and OHCI share the same clock and power,
-	 * resetting twice would cause the 1st controller been reset.
-	 * Therefore only do power up  at the first up device, and
-	 * power down at the last down device.
-	 */
-	if (atomic_dec_return(&usb_pwr_ref) == 0)
-		cns3xxx_pwr_clk_dis(1 << PM_CLK_GATE_REG_OFFSET_USB_HOST);
-}
-
-static struct usb_ehci_pdata cns3xxx_usb_ehci_pdata = {
-	.power_on	= csn3xxx_usb_power_on,
-	.power_off	= csn3xxx_usb_power_off,
-};
-
-static struct usb_ohci_pdata cns3xxx_usb_ohci_pdata = {
-	.num_ports	= 1,
-	.power_on	= csn3xxx_usb_power_on,
-	.power_off	= csn3xxx_usb_power_off,
-};
-
-static const struct of_dev_auxdata cns3xxx_auxdata[] __initconst = {
-	{ "intel,usb-ehci", CNS3XXX_USB_BASE, "ehci-platform", &cns3xxx_usb_ehci_pdata },
-	{ "intel,usb-ohci", CNS3XXX_USB_OHCI_BASE, "ohci-platform", &cns3xxx_usb_ohci_pdata },
-	{ "cavium,cns3420-ahci", CNS3XXX_SATA2_BASE, "ahci", NULL },
-	{ "cavium,cns3420-sdhci", CNS3XXX_SDIO_BASE, "ahci", NULL },
-	{},
-};
-
 static void __init cns3xxx_init(void)
 {
 	struct device_node *dn;
@@ -381,7 +350,6 @@ static void __init cns3xxx_init(void)
 	
 		/* MMC/SD pins share with GPIOA */
 		gpioa_pins |= 0x1fff0004;
-		__raw_writel(gpioa_pins, gpioa);
 	
 		cns3xxx_pwr_clk_en(CNS3XXX_PWR_CLK_EN(SDIO));
 		cns3xxx_pwr_soft_rst(CNS3XXX_PWR_SOFTWARE_RST(SDIO));
@@ -390,7 +358,6 @@ static void __init cns3xxx_init(void)
 
 	pm_power_off = cns3xxx_power_off;
 
-	of_platform_default_populate(NULL, cns3xxx_auxdata, NULL);
 }
 
 static const char *const cns3xxx_dt_compat[] __initconst = {
diff -rup linux-5.15.70-orig/arch/arm/mach-cns3xxx/devices.c linux-5.15.70/arch/arm/mach-cns3xxx/devices.c
--- linux-5.15.70-orig/arch/arm/mach-cns3xxx/devices.c	2022-09-23 22:15:52.000000000 +1000
+++ linux-5.15.70/arch/arm/mach-cns3xxx/devices.c	2022-10-04 19:26:32.791488497 +1100
@@ -13,8 +13,9 @@
 #include <linux/compiler.h>
 #include <linux/dma-mapping.h>
 #include <linux/platform_device.h>
-#include "cns3xxx.h"
-#include "pm.h"
+//#include <mach/irqs.h>
+#include <linux/platform_data/cns3xxx.h>
+#include <mach/pm.h>
 #include "core.h"
 #include "devices.h"
 
@@ -94,9 +95,17 @@ static struct platform_device cns3xxx_sd
 
 void __init cns3xxx_sdhci_init(void)
 {
-	u32 __iomem *gpioa = IOMEM(CNS3XXX_MISC_BASE_VIRT + 0x0014);
+        u32 __iomem *gpioa = IOMEM(CNS3XXX_MISC_BASE_VIRT + 0x0014);  // MISC_GPIOA_PIN_DISABLE_OFFSET
 	u32 gpioa_pins = __raw_readl(gpioa);
 
+#ifdef CONFIG_MACH_SEAGATE
+	printk (" %s WARNING : Loading the sdhci driver will stop usb working\n", __FUNCTION__);
+	printk ("    on the Seagate Central. \n");
+#endif
+	/*
+	 * N.B. The following register change disables USB support
+	 * on Seagate Central Single Drive NAS so use with caution.
+	 */
 	/* MMC/SD pins share with GPIOA */
 	gpioa_pins |= 0x1fff0004;
 	__raw_writel(gpioa_pins, gpioa);
diff -rup linux-5.15.70-orig/arch/arm/mach-cns3xxx/Kconfig linux-5.15.70/arch/arm/mach-cns3xxx/Kconfig
--- linux-5.15.70-orig/arch/arm/mach-cns3xxx/Kconfig	2022-09-23 22:15:52.000000000 +1000
+++ linux-5.15.70/arch/arm/mach-cns3xxx/Kconfig	2022-10-04 19:26:32.791488497 +1100
@@ -1,12 +1,7 @@
 # SPDX-License-Identifier: GPL-2.0
-menuconfig ARCH_CNS3XXX
-	bool "Cavium Networks CNS3XXX family"
-	depends on ARCH_MULTI_V6
-	select ARM_GIC
-	help
-	  Support for Cavium Networks CNS3XXX platform.
+menu "Cavium Networks CNS3XXX family"
 
-if ARCH_CNS3XXX
+depends on ARCH_CNS3XXX
 
 config MACH_CNS3420VB
 	bool "Support for CNS3420 Validation Board"
@@ -17,4 +12,24 @@ config MACH_CNS3420VB
 	  This is a platform with an on-board ARM11 MPCore and has support
 	  for USB, USB-OTG, MMC/SD/SDIO, SATA, PCI-E, etc.
 
-endif
+config MACH_SEAGATE
+	bool "Experimental Seagate Central Single Bay"
+	depends on ATAGS
+	help
+	  This is a platform with an on-board ARM11 MPCore and has support
+	  for USB, USB-OTG, MMC/SD/SDIO, SATA, PCI-E, etc.
+
+config CNS3XXX_HIGH_PHYS_OFFSET
+    bool "High physical base address for the CNS3XXX platform"
+        depends on MMU
+	default y	
+	help
+	  CNS3XXX based systems make RAM available at physical
+	  address 0x20000000, the first 256MB of which is mirrored at
+	  physical address 0x00000000.
+	
+	  If the board has more than 256MB of RAM (unlikely), then
+	  this option allows the unit to access all of that memory
+	  by using the 0x20000000 high physical offset.
+	
+endmenu
diff -rup linux-5.15.70-orig/arch/arm/mach-cns3xxx/Makefile linux-5.15.70/arch/arm/mach-cns3xxx/Makefile
--- linux-5.15.70-orig/arch/arm/mach-cns3xxx/Makefile	2022-09-23 22:15:52.000000000 +1000
+++ linux-5.15.70/arch/arm/mach-cns3xxx/Makefile	2022-10-04 19:26:32.795488531 +1100
@@ -4,3 +4,6 @@ cns3xxx-y				+= core.o pm.o
 cns3xxx-$(CONFIG_ATAGS)			+= devices.o
 cns3xxx-$(CONFIG_PCI)			+= pcie.o
 cns3xxx-$(CONFIG_MACH_CNS3420VB)	+= cns3420vb.o
+cns3xxx-$(CONFIG_MACH_SEAGATE)		+= seagate.o seagate_button.o
+cns3xxx-$(CONFIG_SMP)              	+= platsmp.o headsmp.o cns3xxx_fiq.o
+cns3xxx-$(CONFIG_HOTPLUG_CPU)         	+= hotplug.o
diff -rup linux-5.15.70-orig/arch/arm/mach-cns3xxx/pm.c linux-5.15.70/arch/arm/mach-cns3xxx/pm.c
--- linux-5.15.70-orig/arch/arm/mach-cns3xxx/pm.c	2022-09-23 22:15:52.000000000 +1000
+++ linux-5.15.70/arch/arm/mach-cns3xxx/pm.c	2022-10-04 19:26:32.795488531 +1100
@@ -8,9 +8,15 @@
 #include <linux/io.h>
 #include <linux/delay.h>
 #include <linux/atomic.h>
-#include "cns3xxx.h"
-#include "pm.h"
+#include <linux/platform_data/cns3xxx.h>
+#include <mach/pm.h>
 #include "core.h"
+#include <linux/seq_file.h>
+#include <linux/proc_fs.h>
+
+static struct proc_dir_entry *cns3xxx_pm_proc_entry;
+static struct proc_dir_entry *cns3xxx_pm_clk_proc_entry;
+static struct proc_dir_entry *cns3xxx_pm_pll_pd_proc_entry;
 
 void cns3xxx_pwr_clk_en(unsigned int block)
 {
@@ -30,6 +36,21 @@ void cns3xxx_pwr_clk_dis(unsigned int bl
 }
 EXPORT_SYMBOL(cns3xxx_pwr_clk_dis);
 
+/*
+ * void cns3xxx_pwr_lp_hs - enable lower power handshake
+ * @dev: bitmap for device
+ */
+static void cns3xxx_lp_hs(unsigned int dev)
+{
+    u32 data;
+    void *addr;
+
+    addr = PM_HS_CFG_REG; 
+    data = readl(addr);
+    data |= (PM_HS_CFG_REG_MASK_SUPPORT & dev);
+    writel(data, addr);
+} 
+
 void cns3xxx_pwr_power_up(unsigned int block)
 {
 	u32 reg = __raw_readl(PM_PLL_HM_PD_CTRL_REG);
@@ -116,5 +137,282 @@ int cns3xxx_cpu_clock(void)
 }
 EXPORT_SYMBOL(cns3xxx_cpu_clock);
 
+void cns3xxx_wfi(void)
+{
+
+        mb();
+	asm volatile(
+	    "mov r0, #0\n"
+	    "mcr p15, 0, r0, c7, c10, 4\n"
+	    "mcr p15, 0, r0, c7, c0, 4\n"
+	    );
+}
+EXPORT_SYMBOL(cns3xxx_wfi);
+
+/*
+ * cns3xxx_pwr_mode - change CPU power mode
+ * @pwr_mode: CPU power mode
+ */
+void cns3xxx_pwr_mode(unsigned int pwr_mode)
+{
+        u32 data;
+	u32 __iomem *addr;
+
+	if (CNS3XXX_PWR_CPU_MODE_HIBERNATE < pwr_mode)
+	    return;
+	
+	addr = (u32*)CNS3XXX_PM_BASE_VIRT + 0x014; /* PM_CLK_CTRL_REG */
+	
+	data = readl(addr);
+	data &= ~(0x7 << PM_CLK_CTRL_REG_OFFSET_CPU_PWR_MODE);
+	data |= ((pwr_mode & 0x7)<<PM_CLK_CTRL_REG_OFFSET_CPU_PWR_MODE);
+	writel(data, addr);
+}
+EXPORT_SYMBOL(cns3xxx_pwr_mode);
+
 atomic_t usb_pwr_ref = ATOMIC_INIT(0);
 EXPORT_SYMBOL(usb_pwr_ref);
+
+
+static int cns3xxx_pm_clk_write_proc(struct file *file, const char *buffer,
+				     size_t count, loff_t *ppos)
+{
+    if (count) {
+	unsigned int index = PM_CLK_GATE_REG_OFFSET_SDIO + 1, val = 2;
+	sscanf(buffer, "%u %u", &index, &val);
+	if (1 < val)
+	    goto clk_debug_exit;
+
+	if ((0x1 << index) & PM_CLK_GATE_REG_MASK) {
+	    if (val)
+		PM_CLK_GATE_REG_VALUE |= (0x1 << index);
+	    else
+		PM_CLK_GATE_REG_VALUE &= ~(0x1 << index);
+	}
+    }
+clk_debug_exit:
+    return count;
+}
+
+static int cns3xxx_pm_clk_read_proc(struct seq_file *seq, void *unused) {
+#define CLK_STRING(DEV) \
+    "(%.2d): %s\n", PM_CLK_GATE_REG_OFFSET_##DEV, (0x1 & (reg >> \
+							  PM_CLK_GATE_REG_OFFSET_##DEV)) ? "On" : "Off"
+
+    int reg = PM_CLK_GATE_REG_VALUE;
+
+    seq_printf(seq, "PM_CLK_GATE_REG 0x%.8x\n", reg);
+    seq_printf(seq, "SMC  "CLK_STRING(SMC_NFI));
+    seq_printf(seq, "SPI/I2C "CLK_STRING(SPI_PCM_I2C));
+    seq_printf(seq, "GDMA        "CLK_STRING(GDMA));
+    seq_printf(seq, "RTC  "CLK_STRING(RTC));
+    seq_printf(seq, "UART0   "CLK_STRING(UART0));
+    seq_printf(seq, "UART1   "CLK_STRING(UART1));
+    seq_printf(seq, "UART2   "CLK_STRING(UART2));
+    seq_printf(seq, "GPIO        "CLK_STRING(GPIO));
+    seq_printf(seq, "SWITCH  "CLK_STRING(SWITCH));
+    seq_printf(seq, "HCIE        "CLK_STRING(HCIE));
+    seq_printf(seq, "CRYPTO  "CLK_STRING(CRYPTO));
+    seq_printf(seq, "TIMER   "CLK_STRING(TIMER));
+    seq_printf(seq, "USB_OTG "CLK_STRING(USB_OTG));
+    seq_printf(seq, "USB_HOST"CLK_STRING(USB_HOST));
+    seq_printf(seq, "PCIE1   "CLK_STRING(PCIE(1)));
+    seq_printf(seq, "PCIE0   "CLK_STRING(PCIE(0)));
+    seq_printf(seq, "SATA        "CLK_STRING(SATA));
+    seq_printf(seq, "RAID        "CLK_STRING(RAID));
+    seq_printf(seq, "I2S  "CLK_STRING(I2S));
+    seq_printf(seq, "LCDC        "CLK_STRING(LCDC));
+    seq_printf(seq, "CIM  "CLK_STRING(CIM));
+    seq_printf(seq, "GPU  "CLK_STRING(GPU));
+    seq_printf(seq, "SDIO        "CLK_STRING(SDIO));
+
+    return 0;
+} /* cns3xxx_pm_clk_read_proc() */
+
+static int cns3xxx_pm_clk_open_proc(struct inode *inode, struct file *file)
+{
+    return single_open(file, cns3xxx_pm_clk_read_proc, &inode->i_private);
+}
+
+static const struct proc_ops cns3xxx_pm_clk_fops = {
+    .proc_open           = cns3xxx_pm_clk_open_proc,
+    .proc_read           = seq_read,
+    .proc_lseek          = seq_lseek,
+    .proc_release        = single_release,
+    .proc_write          = cns3xxx_pm_clk_write_proc,
+};
+
+
+static int cns3xxx_pm_pll_pd_write_proc(struct file *file, const char *buffer,
+					size_t count, loff_t *ppos)
+{
+    if (count) {
+	unsigned int index = PM_PLL_HM_PD_CTRL_REG_OFFSET_SATA_PHY1 + 1;
+	unsigned int val = 2;
+	sscanf(buffer, "%u %u", &index, &val);
+	if (1 < val)
+	    goto clk_debug_exit;
+
+	if ((0x1 << index) & PM_PLL_HM_PD_CTRL_REG_MASK) {
+	    if (val)
+		PM_PLL_HM_PD_CTRL_REG_VALUE |= (0x1 << index);
+	    else
+		PM_PLL_HM_PD_CTRL_REG_VALUE &= ~(0x1 << index);
+	}
+    }
+clk_debug_exit:
+    return count;
+} /* cns3xxx_pm_pll_pd_write_proc() */
+
+static int cns3xxx_pm_pll_pd_read_proc(struct seq_file *seq, void *unused)
+{
+#define PLL_PD_STRING(DEV) \
+    "(%.2d): %s\n", \
+	PM_PLL_HM_PD_CTRL_REG_OFFSET_PLL_##DEV, \
+	(0x1 & (reg>>PM_PLL_HM_PD_CTRL_REG_OFFSET_PLL_##DEV)) ? "Power Down" : \
+	        "Power Up"
+
+#define PHY_PD_STRING(DEV) \
+    "(%.2d): %s\n", \
+	PM_PLL_HM_PD_CTRL_REG_OFFSET_##DEV, \
+	(0x1 & (reg >> PM_PLL_HM_PD_CTRL_REG_OFFSET_##DEV)) ? "Power Down" : \
+	        "Power Up"
+
+    int reg = PM_PLL_HM_PD_CTRL_REG_VALUE;
+
+    seq_printf(seq, "PM_PLL_HM_PD_CTRL_REG 0x%.8x\n", reg);
+    seq_printf(seq, "RGMII        "PLL_PD_STRING(RGMII));
+    seq_printf(seq, "USB    "PLL_PD_STRING(USB));
+    seq_printf(seq, "LCD    "PLL_PD_STRING(LCD));
+    seq_printf(seq, "I2S    "PLL_PD_STRING(I2S));
+    seq_printf(seq, "I2SCD        "PLL_PD_STRING(I2SCD));
+    seq_printf(seq, "SATA_PHY0 "PHY_PD_STRING(SATA_PHY0));
+    seq_printf(seq, "SATA_PHY1 "PHY_PD_STRING(SATA_PHY1));
+
+    return 0;
+} /* cns3xxx_pm_pll_pd_read_proc() */
+
+static int cns3xxx_pm_pll_pd_open_proc(struct inode *inode, struct file *file)
+{
+    return single_open(file, cns3xxx_pm_pll_pd_read_proc, &inode->i_private);
+}
+
+static const struct proc_ops cns3xxx_pm_pll_pd_fops = {
+    .proc_open           = cns3xxx_pm_pll_pd_open_proc,
+    .proc_read           = seq_read,
+    .proc_lseek          = seq_lseek,
+    .proc_release        = single_release,
+    .proc_write          = cns3xxx_pm_pll_pd_write_proc,
+};
+
+
+const int ddr_speed_str[] = {200, 266, 333, 400};
+
+static int cns3xxx_pm_read_proc(struct seq_file *seq, void *unused)
+{
+
+    seq_printf(seq, "CLK_GATE_REG         0x%.8x\n",
+	       PM_CLK_GATE_REG_VALUE);
+    seq_printf(seq, "SOFT_RST_REG         0x%.8x\n",
+	       PM_SOFT_RST_REG_VALUE);
+    seq_printf(seq, "HS_CFG_REG     0x%.8x\n", PM_HS_CFG_REG_VALUE);
+    seq_printf(seq, "CACTIVE_STA_REG       0x%.8x\n",
+	       PM_CACTIVE_STA_REG_VALUE);
+    seq_printf(seq, "PWR_STA_REG   0x%.8x\n", PM_PWR_STA_REG_VALUE);
+    seq_printf(seq, "CLK_CTRL_REG         0x%.8x\n",
+	       PM_CLK_CTRL_REG_VALUE);
+    seq_printf(seq, "PLL_LCD_I2S_CTRL_REG 0x%.8x\n",
+	       PM_PLL_LCD_I2S_CTRL_REG_VALUE);
+    seq_printf(seq, "PLL_HM_PD_CTRL_REG   0x%.8x\n",
+	       PM_PLL_HM_PD_CTRL_REG_VALUE);
+    seq_printf(seq, "REGULAT_CTRL_REG     0x%.8x\n",
+	       PM_REGULAT_CTRL_REG_VALUE);
+    seq_printf(seq, "WDT_CTRL_REG         0x%.8x\n",
+	       PM_WDT_CTRL_REG_VALUE);
+    seq_printf(seq, "WU_CTRL0_REG         0x%.8x\n",
+	       PM_WU_CTRL0_REG_VALUE);
+    seq_printf(seq, "WU_CTRL1_REG         0x%.8x\n",
+	       PM_WU_CTRL1_REG_VALUE);
+    seq_printf(seq, "CSR_REG 0x%.8x\n", PM_CSR_REG_VALUE);
+
+    seq_printf(seq, "PLL CPU Frequency: ");
+    switch (PM_CLK_CTRL_REG_VALUE & 0xf) {
+    case 0:
+	seq_printf(seq, "300MHz\n");
+	break;
+    case 1:
+	seq_printf(seq, "333MHz\n");
+	break;
+    case 2:
+	seq_printf(seq, "366MHz\n");
+	break;
+    case 3:
+	seq_printf(seq, "400MHz\n");
+	break;
+    case 4:
+	seq_printf(seq, "433MHz\n");
+	break;
+    case 5:
+	seq_printf(seq, "466MHz\n");
+	break;
+    case 6:
+	seq_printf(seq, "500MHz\n");
+	break;
+    case 7:
+	seq_printf(seq, "533MHz\n");
+	break;
+    case 8:
+	seq_printf(seq, "566MHz\n");
+	break;
+    case 9:
+	seq_printf(seq, "600MHz\n");
+	break;
+    default:
+	seq_printf(seq, "!!!!!\n");
+    }
+
+    seq_printf(seq, "CPU clock divider: %d\n",
+		   0x1 << ((PM_CLK_CTRL_REG_VALUE >> 4) & 0x3));
+    seq_printf(seq, "CPU clock: %d MHz\n",
+		   cns3xxx_cpu_clock());
+    seq_printf(seq, "DDR2 clock %d MHz\n",
+		   ddr_speed_str[(PM_CLK_CTRL_REG_VALUE >> 7) & 0x3]);
+    
+    return 0;
+}
+
+static int cns3xxx_pm_open_proc(struct inode *inode, struct file *file)
+{
+    return single_open(file, cns3xxx_pm_read_proc, &inode->i_private);
+}
+
+static const struct proc_ops cns3xxx_pm_fops = {
+    .proc_open           = cns3xxx_pm_open_proc,
+    .proc_read           = seq_read,
+    .proc_lseek         = seq_lseek,
+    .proc_release        = single_release,
+};
+
+static int __init cns3xxx_pm_proc_init(void)
+{
+    cns3xxx_pm_proc_entry = proc_create("pm", S_IFREG | S_IRUGO,
+					cns3xxx_proc_dir, &cns3xxx_pm_fops);
+    cns3xxx_pm_clk_proc_entry = proc_create("pm_clk", S_IFREG | S_IRUGO,
+					    cns3xxx_proc_dir, &cns3xxx_pm_clk_fops);
+    cns3xxx_pm_pll_pd_proc_entry = proc_create("pm_pll_pd", S_IFREG | S_IRUGO,
+					       cns3xxx_proc_dir, &cns3xxx_pm_pll_pd_fops);
+    return 1;
+}
+
+
+static int __init cns3xxx_pm_init(void) {
+
+    cns3xxx_lp_hs(PM_HS_CFG_REG_MASK_SUPPORT);
+    cns3xxx_pm_proc_init();
+    return 0;
+}
+        
+
+
+
+late_initcall(cns3xxx_pm_init);
diff -rup linux-5.15.70-orig/arch/arm/mm/copypage-v6.c linux-5.15.70/arch/arm/mm/copypage-v6.c
--- linux-5.15.70-orig/arch/arm/mm/copypage-v6.c	2022-09-23 22:15:52.000000000 +1000
+++ linux-5.15.70/arch/arm/mm/copypage-v6.c	2022-10-04 19:26:32.795488531 +1100
@@ -17,10 +17,6 @@
 
 #include "mm.h"
 
-#if SHMLBA > 16384
-#error FIX ME
-#endif
-
 static DEFINE_RAW_SPINLOCK(v6_lock);
 
 /*
diff -rup linux-5.15.70-orig/arch/arm/mm/dma.h linux-5.15.70/arch/arm/mm/dma.h
--- linux-5.15.70-orig/arch/arm/mm/dma.h	2022-09-23 22:15:52.000000000 +1000
+++ linux-5.15.70/arch/arm/mm/dma.h	2022-10-04 19:26:32.795488531 +1100
@@ -5,8 +5,13 @@
 #include <asm/glue-cache.h>
 
 #ifndef MULTI_CACHE
+#ifndef CONFIG_DMA_CACHE_FIQ_BROADCAST
 #define dmac_map_area			__glue(_CACHE,_dma_map_area)
 #define dmac_unmap_area 		__glue(_CACHE,_dma_unmap_area)
+#else
+#define dmac_map_area                   __glue(fiq,_dma_map_area)
+#define dmac_unmap_area                 __glue(fiq,_dma_unmap_area)
+#endif
 
 /*
  * These are private to the dma-mapping API.  Do not use directly.
diff -rup linux-5.15.70-orig/arch/arm/mm/dump.c linux-5.15.70/arch/arm/mm/dump.c
--- linux-5.15.70-orig/arch/arm/mm/dump.c	2022-09-23 22:15:52.000000000 +1000
+++ linux-5.15.70/arch/arm/mm/dump.c	2022-10-04 19:26:32.795488531 +1100
@@ -309,8 +309,11 @@ static void walk_pte(struct pg_state *st
 	pte_t *pte = pte_offset_kernel(pmd, 0);
 	unsigned long addr;
 	unsigned i;
-
+#ifdef CONFIG_ARM_64KB_MMU_PAGE_SIZE_SUPPORT
+	for (i = 0; i < PTRS_PER_PTE_REAL; i++, pte += PTE_STEP) {
+#else
 	for (i = 0; i < PTRS_PER_PTE; i++, pte++) {
+#endif
 		addr = start + i * PAGE_SIZE;
 		note_page(st, addr, 5, pte_val(*pte), domain);
 	}
diff -rup linux-5.15.70-orig/arch/arm/mm/fault.c linux-5.15.70/arch/arm/mm/fault.c
--- linux-5.15.70-orig/arch/arm/mm/fault.c	2022-09-23 22:15:52.000000000 +1000
+++ linux-5.15.70/arch/arm/mm/fault.c	2022-10-04 19:26:32.795488531 +1100
@@ -26,6 +26,19 @@
 
 #ifdef CONFIG_MMU
 
+#ifdef CONFIG_ARM_64KB_MMU_PAGE_SIZE_SUPPORT
+static long long get_large_pte_hw_val(pte_t *pte)
+{
+    unsigned long pte_ptr = (unsigned long)pte;
+    unsigned long tmp = pte_ptr;
+
+    pte_ptr += (PTE_HWTABLE_PTRS * sizeof(void *));
+    pte_ptr &= ~0x7FC;
+    tmp &= 0x7FC & (~(((PAGE_SHIFT - 12) - 1) << 7));
+    pte_ptr += (tmp << (PAGE_SHIFT - 12));
+    return (long long)pte_val(*(pte_t *)pte_ptr);
+}
+#endif
 /*
  * This is useful to dump out the page tables associated with
  * 'addr' in mm 'mm'.
@@ -87,9 +100,14 @@ void show_pte(const char *lvl, struct mm
 		pte = pte_offset_map(pmd, addr);
 		pr_cont(", *pte=%08llx", (long long)pte_val(*pte));
 #ifndef CONFIG_ARM_LPAE
+#ifdef CONFIG_ARM_64KB_MMU_PAGE_SIZE_SUPPORT
+		pr_cont(", *ppte=%08llx", get_large_pte_hw_val(pte));
+		
+#else
 		pr_cont(", *ppte=%08llx",
 		       (long long)pte_val(pte[PTE_HWTABLE_PTRS]));
-#endif
+#endif /* CONFIG_ARM_64KB_MMU_PAGE_SIZE_SUPPORT */
+#endif /* CONFIG_ARM_LPAE */
 		pte_unmap(pte);
 	} while(0);
 
diff -rup linux-5.15.70-orig/arch/arm/mm/flush.c linux-5.15.70/arch/arm/mm/flush.c
--- linux-5.15.70-orig/arch/arm/mm/flush.c	2022-09-23 22:15:52.000000000 +1000
+++ linux-5.15.70/arch/arm/mm/flush.c	2022-10-04 19:26:32.795488531 +1100
@@ -315,6 +315,7 @@ void __sync_icache_dcache(pte_t pteval)
 void flush_dcache_page(struct page *page)
 {
 	struct address_space *mapping;
+	bool skip_broadcast = true;
 
 	/*
 	 * The zero page is never written to, so never has any dirty
@@ -331,7 +332,11 @@ void flush_dcache_page(struct page *page
 
 	mapping = page_mapping_file(page);
 
-	if (!cache_ops_need_broadcast() &&
+#ifndef CONFIG_DMA_CACHE_FIQ_BROADCAST
+	skip_broadcast = !cache_ops_need_broadcast();
+#endif
+
+	if (skip_broadcast &&
 	    mapping && !page_mapcount(page))
 		clear_bit(PG_dcache_clean, &page->flags);
 	else {
diff -rup linux-5.15.70-orig/arch/arm/mm/Kconfig linux-5.15.70/arch/arm/mm/Kconfig
--- linux-5.15.70-orig/arch/arm/mm/Kconfig	2022-09-23 22:15:52.000000000 +1000
+++ linux-5.15.70/arch/arm/mm/Kconfig	2022-10-04 19:26:32.803488600 +1100
@@ -937,6 +937,17 @@ config DMA_CACHE_RWFO
 	  in hardware, other workarounds are needed (e.g. cache
 	  maintenance broadcasting in software via FIQ).
 
+config DMA_CACHE_FIQ_BROADCAST
+        bool "Enable fiq broadcast DMA cache maintenance"
+	depends on CPU_V6K && SMP
+	select FIQ
+	help
+	  The Snoop Control Unit on ARM11MPCore does not detect the
+	  cache maintenance operations and the dma_{map,unmap}_area()
+	  functions may leave stale cache entries on other CPUs. By
+	  enabling this option, fiq broadcast in the ARMv6
+	  DMA cache maintenance functions is performed.
+	  
 config OUTER_CACHE
 	bool
 
@@ -984,6 +995,16 @@ config MIGHT_HAVE_CACHE_L2X0
 	  instead of this option, thus preventing the user from
 	  inadvertently configuring a broken kernel.
 
+config ARM_64KB_MMU_PAGE_SIZE_SUPPORT
+        bool "64KB MMU page size support"
+        help
+          The kernel and page-table will use large 64KB pages.
+          Note that this feature enables support for large storage volumes
+          at the expense of higher memory fragmentation by enabling the
+          use of up to 64KB block sizes.
+          This is commonly required to access file systems used by
+          commercial NAS devices.
+
 config CACHE_L2X0
 	bool "Enable the L2x0 outer cache controller" if MIGHT_HAVE_CACHE_L2X0
 	default MIGHT_HAVE_CACHE_L2X0
diff -rup linux-5.15.70-orig/arch/arm/mm/mmu.c linux-5.15.70/arch/arm/mm/mmu.c
--- linux-5.15.70-orig/arch/arm/mm/mmu.c	2022-09-23 22:15:52.000000000 +1000
+++ linux-5.15.70/arch/arm/mm/mmu.c	2022-10-04 19:26:32.803488600 +1100
@@ -355,7 +355,11 @@ static pte_t bm_pte[PTRS_PER_PTE + PTE_H
 
 static pte_t * __init pte_offset_early_fixmap(pmd_t *dir, unsigned long addr)
 {
+#ifdef CONFIG_ARM_64KB_MMU_PAGE_SIZE_SUPPORT
+	return &bm_pte[pte_index(addr) * PTE_STEP];
+#else
 	return &bm_pte[pte_index(addr)];
+#endif
 }
 
 static pte_t *pte_offset_late_fixmap(pmd_t *dir, unsigned long addr)
@@ -725,7 +729,9 @@ static pte_t * __init arm_pte_alloc(pmd_
 				void *(*alloc)(unsigned long sz))
 {
 	if (pmd_none(*pmd)) {
-		pte_t *pte = alloc(PTE_HWTABLE_OFF + PTE_HWTABLE_SIZE);
+	        pte_t *pte = alloc(round_up(PTE_HWTABLE_OFF +
+					    PTE_HWTABLE_SIZE,
+					    PAGE_SIZE));
 		__pmd_populate(pmd, __pa(pte), prot);
 	}
 	BUG_ON(pmd_bad(*pmd));
@@ -749,7 +755,11 @@ static void __init alloc_init_pte(pmd_t
 		set_pte_ext(pte, pfn_pte(pfn, __pgprot(type->prot_pte)),
 			    ng ? PTE_EXT_NG : 0);
 		pfn++;
+#ifdef CONFIG_ARM_64KB_MMU_PAGE_SIZE_SUPPORT
+	} while (pte += PTE_STEP, addr += PAGE_SIZE, addr != end);
+#else
 	} while (pte++, addr += PAGE_SIZE, addr != end);
+#endif
 }
 
 static void __init __map_init_section(pmd_t *pmd, unsigned long addr,
@@ -1358,7 +1368,16 @@ static void __init devicemaps_init(const
 	/*
 	 * Allocate the vector page early.
 	 */
+#ifdef CONFIG_ARM_64KB_MMU_PAGE_SIZE_SUPPORT
+        /*
+	 * With large page support, the pages are at least 8K, so
+	 * there is enough space in one page for the stubs that are
+	 * copied at 4K offset.
+	 */
+	vectors = early_alloc(PAGE_SIZE);
+#else
 	vectors = early_alloc(PAGE_SIZE * 2);
+#endif
 
 	early_trap_init(vectors);
 
@@ -1428,13 +1447,22 @@ static void __init devicemaps_init(const
 		map.type = MT_LOW_VECTORS;
 		create_mapping(&map);
 	}
-
+	
+	/*
+	 * With large page support, the pages are at least 8K, so this
+	 * hardware page was already mapped. Actually the hardcoded
+	 * 4KB offset cause trouble with the virtual address passed
+	 * to create_mapping: the address is no more aligned to a
+	 * page.
+	 */
+#ifndef CONFIG_ARM_64KB_MMU_PAGE_SIZE_SUPPORT
 	/* Now create a kernel read-only mapping */
 	map.pfn += 1;
 	map.virtual = 0xffff0000 + PAGE_SIZE;
 	map.length = PAGE_SIZE;
 	map.type = MT_LOW_VECTORS;
 	create_mapping(&map);
+#endif
 
 	/*
 	 * Ask the machine support to map in the statically mapped devices.
diff -rup linux-5.15.70-orig/arch/arm/mm/pgd.c linux-5.15.70/arch/arm/mm/pgd.c
--- linux-5.15.70-orig/arch/arm/mm/pgd.c	2022-09-23 22:15:52.000000000 +1000
+++ linux-5.15.70/arch/arm/mm/pgd.c	2022-10-04 19:26:32.803488600 +1100
@@ -119,7 +119,9 @@ pgd_t *pgd_alloc(struct mm_struct *mm)
 		init_pmd = pmd_offset(init_pud, 0);
 		init_pte = pte_offset_map(init_pmd, 0);
 		set_pte_ext(new_pte + 0, init_pte[0], 0);
+#ifndef CONFIG_ARM_64KB_MMU_PAGE_SIZE_SUPPORT		
 		set_pte_ext(new_pte + 1, init_pte[1], 0);
+#endif
 		pte_unmap(init_pte);
 		pte_unmap(new_pte);
 	}
diff -rup linux-5.15.70-orig/arch/arm/mm/proc-macros.S linux-5.15.70/arch/arm/mm/proc-macros.S
--- linux-5.15.70-orig/arch/arm/mm/proc-macros.S	2022-09-23 22:15:52.000000000 +1000
+++ linux-5.15.70/arch/arm/mm/proc-macros.S	2022-10-04 19:26:32.803488600 +1100
@@ -155,8 +155,16 @@
 
 	bic	r3, r1, #0x000003fc
 	bic	r3, r3, #PTE_TYPE_MASK
+#ifdef CONFIG_ARM_64KB_MMU_PAGE_SIZE_SUPPORT
+	bic     r3, r3, #0x00000F000
+#endif
 	orr	r3, r3, r2
-	orr	r3, r3, #PTE_EXT_AP0 | 2
+#ifdef CONFIG_ARM_64KB_MMU_PAGE_SIZE_SUPPORT
+	orr     r3, r3, #PTE_EXT_AP0 | PTE_TYPE_LARGE
+#else
+	orr     r3, r3, #PTE_EXT_AP0 | PTE_TYPE_SMALL
+#endif
+
 
 	adr	ip, \pfx\()_mt_table
 	and	r2, r1, #L_PTE_MT_MASK
@@ -184,8 +192,28 @@
 	tstne	r1, #L_PTE_NONE
 	movne	r3, #0
 
+#ifdef CONFIG_ARM_64KB_MMU_PAGE_SIZE_SUPPORT
+
+	/* Bits 6, 7, 8 SBZ */
+	bic     r3, r3, #0x000001c0
+
+	/*	
+         * Repeat the hw entry 16 times in case of 64k page
+         * This is a requirement from the hw ;
+         * linux ptes need not be repeated.
+        */
+	mov     r1, #16
+.Lrpt_for_hw:
+	str     r3, [r0]
+	mcr     p15, 0, r0, c7, c10, 1          @ flush_pte
+	add     r0, r0, #4
+	subs    r1, r1, #1
+	bne     .Lrpt_for_hw
+
+#else /* CONFIG_ARM_64KB_MMU_PAGE_SIZE_SUPPORT */
 	str	r3, [r0]
 	mcr	p15, 0, r0, c7, c10, 1		@ flush_pte
+#endif /* CONFIG_ARM_64KB_MMU_PAGE_SIZE_SUPPORT */
 	.endm
 
 
diff -rup linux-5.15.70-orig/arch/arm/mm/proc-v6.S linux-5.15.70/arch/arm/mm/proc-v6.S
--- linux-5.15.70-orig/arch/arm/mm/proc-v6.S	2022-09-23 22:15:52.000000000 +1000
+++ linux-5.15.70/arch/arm/mm/proc-v6.S	2022-10-04 19:26:32.803488600 +1100
@@ -95,21 +95,31 @@ ENTRY(cpu_v6_dcache_clean_area)
  */
 ENTRY(cpu_v6_switch_mm)
 #ifdef CONFIG_MMU
-	mov	r2, #0
 	mmid	r1, r1				@ get mm->context.id
-	ALT_SMP(orr	r0, r0, #TTB_FLAGS_SMP)
-	ALT_UP(orr	r0, r0, #TTB_FLAGS_UP)
-	mcr	p15, 0, r2, c7, c5, 6		@ flush BTAC/BTB
-	mcr	p15, 0, r2, c7, c10, 4		@ drain write buffer
-	mcr	p15, 0, r0, c2, c0, 0		@ set TTB 0
 #ifdef CONFIG_PID_IN_CONTEXTIDR
 	mrc	p15, 0, r2, c13, c0, 1		@ read current context ID
 	bic	r2, r2, #0xff			@ extract the PID
 	and	r1, r1, #0xff
 	orr	r1, r1, r2			@ insert into new context ID
 #endif
+	mov	r2, #0
+	ALT_SMP(orr	r0, r0, #TTB_FLAGS_SMP)
+	ALT_UP(orr	r0, r0, #TTB_FLAGS_UP)
+	mcr	p15, 0, r2, c7, c5, 6		@ flush BTAC/BTB
+#ifdef CONFIG_ARM_64KB_MMU_PAGE_SIZE_SUPPORT	
+	mcr     p15, 0, r2, c7, c10, 4          @ dsb
+	mcr     p15, 0, r2, c13, c0, 1          @ set reserved context ID
+	mcr     p15, 0, r2, c7, c5, 4           @ isb
+	mcr     p15, 0, r0, c2, c0, 0           @ set TTB 0
+	mcr     p15, 0, r2, c7, c5, 4           @ isb
+	mcr     p15, 0, r1, c13, c0, 1          @ set context ID
+	mcr     p15, 0, r2, c7, c5, 4           @ isb
+#else	
+	mcr	p15, 0, r2, c7, c10, 4		@ drain write buffer
+	mcr	p15, 0, r0, c2, c0, 0		@ set TTB 0
 	mcr	p15, 0, r1, c13, c0, 1		@ set context ID
-#endif
+#endif	/* CONFIG_ARM_64KB_MMU_PAGE_SIZE_SUPPORT */
+#endif	/* CONFIG_MMU */
 	ret	lr
 
 /*
